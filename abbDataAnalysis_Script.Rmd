---
title: "Abb Analysis"
author: "Andy Krause and Gideon Aschwanden"
date: "February 5, 2017"
output: html_document
---

### Introduction

&nbsp;

### Preliminary Commands

&nbsp;

```{r load_libraries, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}

  library(spdep)
  library(maptools)
  library(gstat)
  library(ggplot2)
  library(geosphere)
  library(ggmap)
  library(xtable)
  library(chron)
  library(plyr)
  library(sp)
  library(rgeos)
  library(reshape2)
  library(stringr)
  library(RColorBrewer)
  library(Hmisc)
  library(kernlab)

```


```{r set_paths, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}

  # Get computer names

  comp.name <- Sys.info()['nodename']

  # Assign path based on computer name
  
  if(comp.name == '7020D-121777-W' | comp.name == 'DESKTOP-1D7JO4J'){
  
    data.path <- 'c:/dropbox/research/airBNB/data/'
    code.path <- 'c:/code/'
    fig.path <- 'c:/dropbox/research/airBNB/figures/'

  } else {
  
    data.path <- 'alternate data path'
    code.path <- 'alternate data path'
    fig.path <- 'alternate data path'
    
  }

```

Next, we source the necessary custom code files for the analysis.  
  
```{r source_files, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}

 # Current Project files

  source(paste0(code.path, "research/AirBNBMelbourne/abb_Functions.R"))

 # Other custom files

  source(paste0('https://raw.githubusercontent.com/andykrause/dataVizTools',
                '/master/ggPlotTools.R'))
  source(paste0('https://raw.githubusercontent.com/andykrause/datamgmttools',
                '/master/dataMungeTools.R'))
  source(paste0('https://raw.githubusercontent.com/andykrause/spatialTools',
                '/master/spatialLogitModels.R'))
  source(paste0('https://raw.githubusercontent.com/andykrause/spatialTools',
                '/master/point2surface_Tools.R'))

```


```{r load_str_data, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  # Property Information

  load(paste0(data.path, 'prepared/prep_workspace.RData'))

```

State gives energy costs at 330 (apt) to 520 (house).  For 2 person in apt that works out to 5 per person per day.  For house of 4 that works out to about 4 per person per day.  

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str.data$cpppd <- 4.5
  str.data$avg.guests <- str.data$bedrooms * 1.5

  str.data$str.act.revenue <- ((str.data$bookings * str.data$med.rate) - 
                                 (str.data$bookings * str.data$avg.guests * str.data$cpppd))

  str.data$extr.par <- 366 / str.data$total.days

  str.data$str.ext.revenue <- ((str.data$bookings * str.data$extr.par *
                                  str.data$med.rate) - 
                                 (str.data$bookings * str.data$avg.guests * 
                                    str.data$cpppd * str.data$extr.par))
  # 
  str.data$occ.rate <- 1 - (str.data$block.rate + str.data$avail.rate)

  str.data$pot.occ.rate <- ((str.data$bookings * str.data$extr.par) / 
    (366 - (366 * str.data$block.rate))) 
  
  str.data$str.pot.revenue <- ((str.data$pot.occ.rate * 366 * str.data$med.rate) - 
                                 (str.data$pot.occ.rate * 366  * str.data$avg.guests *  
                                    str.data$cpppd))
  

```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  # Calculate the actual revenue
  ltr.data$ltr.revenue <- ltr.data$event.price * (52 - ltr.data$dom / 7)
  
  # Remove those with very low revenues (due to very long DOMs)
  ltr.data <- ltr.data[ltr.data$ltr.revenue > 10000, ]
  
  countCleaning('revenue')

```

### Host types


```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  ggplot(str.data, aes(x=block.rate)) + 
  geom_density(fill=str.col, color=str.col) +
  ylab('Frequency\n') + 
  xlab('\n% of Time Property is Blocked') +
  scale_x_continuous(breaks=seq(0,1,.2),
                     labels=c('0%', '20%', '40%', '60%', '80%', '100%')) +
    ggtitle('Host Block Rate Frequency\n') +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank())



```


```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  ggplot(str.data, aes(x=block.rate, y=nbr.block*extr.par)) + 
  geom_point(fill=str.col, color=str.col, size=.2) +
  ylab('Frequency\n') + 
  xlab('\n% of Time Property is Blocked') +
  scale_x_continuous(breaks=seq(0, 1, .2),
                     labels=c('0%', '20%', '40%', '60%', '80%', '100%')) +
    ggtitle('Host Block Rate Frequency\n') +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank())

```



```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

str.data$blockpertime <- round(str.data$nbr.block * str.data$extr.par, 1)

str.data$host.type <- 'Unknown'
str.data$host.type[str.data$blockpertime > 12] <- 'Multi-Platform User'
str.data$host.type[str.data$block.rate <= .25] <- 'Profit Seeker'
str.data$host.type[str.data$block.rate >= .75] <- 'Opportunistic Sharer'
str.data$host.type <- factor(str.data$host.type,
                             levels=c('Profit Seeker', 'Opportunistic Sharer', 
                                      'Multi-Platform User', 'Unknown'))

ggplot(str.data, 
       aes(x=block.rate, y=blockpertime, color=host.type)) + 
  geom_point(alpha=.5, size=.8, shape=15) +
  scale_color_manual(values=c(abb.col[2], abb.col[4], abb.col[7], abb.col[9]))

```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

ggplot(str.data, aes(host.type, fill=host.type)) +
  geom_bar() +
  scale_fill_manual(values=c(abb.col[2], abb.col[4], abb.col[7], abb.col[9]))+
  theme(legend.position='none')

```

## Global Market Analysis

We now analyze the full metro market to test which properties are more profitable as short-term rentals.  

We start by specifying the imputation models for the LTR and the Airbnb datasets

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  ltr.mod.spec <- formula(log(event.price) ~ as.factor(type) + 
                            as.factor(bedbath) + as.factor(suburb) + 
                            as.factor(ltr.month))

```


We then employ a custom function to cross impute rates and rents for the two datasets.  The 'clip.field' is a spatial fixed effects that add spatial recognition to the models. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
  
  imp.data <- imputeLtrRents(ltr.df=ltr.data, 
                               str.df=str.data, 
                               mod.spec=ltr.mod.spec,
                               match.factor='suburb')

```

From the imputed results, we extract the base data (with imputed values) as well as the model summaries. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  # Extract out DFs (only those that imputed)
  str.glob <- merge(str.data, imp.data$imp.rent, by='property.id')

```

Next we cross impute days on market and occupancy rates.

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  # Apply dom to abb
  str.glob$imp.dom <- imputeDOM(str.glob, ltr.data, calc.type='median')
  

```

With the cross-imputed DOMs and occupancy rates we now make the cross-tenure imputations of revenues and add them back to the original datasets. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str.glob$ltr.imp.revenue <- str.glob$imp.rent * (52 - str.glob$imp.dom / 7)

```

Next, we compare the revenues from the two and extract the new datasets.

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  comp.revs <- compareRevenues(str.glob)

  str.glob <- merge(str.glob, comp.revs, by='property.id')

```

Realizing that the imputed long term rental values may be more accurate when estimated at smaller scales, we functionalize the above processes and then apply it to short term rentals, broken into submarkets by type, bed/bath and geographic area.  In other words, we separately estimate LTR rents for Apartments with 1bed/1bath in the city core, Apartments with 1bed/1bath in the beach submarket, etc. for all compbinations of type, bed/bath and geographic area. We then combine the results form all estimates back into a single data.frame that contains all of the short-term rentals. 

```{r build.tbg.data, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 # Create the type, bed/bath and geo sub market variable

 str.data$tbg <- paste0(str.data$product,'.', str.data$sub.mrkt)
 ltr.data$tbg <- paste0(ltr.data$product,'.', ltr.data$sub.mrkt)

 # Make IC estimates at TBG level

 str.data.ic <- abbImputeCompare(str.df=str.data,
                                 ltr.df=ltr.data,
                                 mod.spec=ltr.mod.spec,
                                 match.factor='suburb',
                                 split.field='tbg',
                                 verbose=TRUE)


```


## Analyze Results

First we make a comparison table of the results, broken down by submarket.  

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 # Make Basic comparison table
  pref.table <- abbCreateCompTable(ic.df=str.data.ic,
                                   split.field='sub.mrkt')

 # Convert to wide format for output
  pref.table.wide <- dcast(pref.table, ID ~ rev.type, value.var='Var')

 # Limit to the extrapolated pref type
  pref.table <- pref.table[pref.table$rev.type == 'Extrapolated', ]
    
```

We then turn this into a simple chart to see the differences

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
    
  sm.col <- abb.col[c(1, 3, 6, 5, 2)]

  ggplot(pref.table, aes(x=ID, weights=Var, fill=ID)) + 
    geom_bar() +
    facet_grid(~rev.type) +
    scale_fill_manual(values=sm.col) +
    xlab('') +
    ylab('% of properties where Airbnb is more profitable') +
    scale_y_continuous(breaks=c(0,.25,.5,.75,1),
                       labels=c('0%', '25%', '50%', '75%', '100%')) +
    theme(legend.position='none')

```

Next, we plot the \% of properties that have short-term preference versus the occupancy rate

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str.data.ic$pref <- str.data.ic$str.ext.pref

  rawocc.pplot <- abbPrefPlot(str.data.ic,
                               x.field='occ.rate',
                               split.field='sub.mrkt',
                               smooth=TRUE,
                               smooth.span=.35 ,
                              spl.col=sm.col)
  rawocc.pplot
  

```


Looking at the distribution of occupancy rates, we that it is not uniform in any of the submarkets.  

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  ggplot(str.data.ic, aes(x=occ.rate, group=sub.mrkt, color=sub.mrkt, fill=sub.mrkt)) +
    geom_density(alpha=.3) +
    facet_wrap(~sub.mrkt) +
    scale_color_manual(values=sm.col) +
    scale_fill_manual(values=sm.col) +
    scale_x_continuous(breaks=seq(0, 1, by=.5),
                       labels=c('0%', '50%', '100%')) +
    ylab('') +
    xlab('Occupancy Rate') +
    theme(legend.position='none',
          axis.line=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.y=element_blank())

```

We then calculate quantile values for rates and replot the charts

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str.data.ic$occ.qtl <- makeWtdQtl(str.data.ic$occ.rate, 
                                      return.type='rank') 
  str.data.ic$rate.qtl <- makeWtdQtl(str.data.ic$med.rate, 
                                  return.type='rank') 
  
  ## Make quartile location plot
  
  qtlocc.pplot <- abbPrefPlot(str.data.ic,
                               x.field='occ.qtl',
                               split.field='sub.mrkt',
                               smooth=TRUE,
                               smooth.span=.75)
  qtlocc.pplot <- qtlocc.pplot +
    xlab('\nQualtile of Occupancy Rate') +
    ylab('\n% of Properties where Airbnb is more profitable') +
    scale_x_continuous(breaks=seq(0, 100, by=25),
                       labels=c('0', '25th', '50th', '75th', '100th')) +
    scale_y_continuous(breaks=seq(0, 1, by=.25),
                       labels=c('0%', '25%', '50%', '75%', '100%')) +
    scale_color_manual(values=sm.col)
  
  qtlocc.pplot
  

```

Next we build a heat map that shows which combinations of occ rate and nightly rate are most likely to result in short-term preference.

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
  
  rate.hm <- abbHeatMap(str.data.ic,
                x.field='occ.rate',
                y.field='nightly.rate',
                pref.field='str.ext.pref',
                svm=F, 
                alpha.count=T,
                add.points=T,
                fill.colors=c(abb.col[1], abb.col[5]))
  rate.hm
  
```

To make the distinction more clear, we employ a Support Vector Machine to classify the areas into short and long term preference. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  rate.hm.svm <- abbHeatMap(str.data.ic,
                            x.field='occ.rate',
                            y.field='nightly.rate',
                            pref.field='str.ext.pref',
                            svm=T, 
                            alpha.count=F,
                            add.points=T,
                            fill.colors=c(abb.col[1], abb.col[5]))
  rate.hm.svm

  
```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
  
  qtl.hm <- abbHeatMap(str.data.ic,
                x.field='occ.qtl',
                y.field='rate.qtl',
                pref.field='str.ext.pref',
                svm=F, 
                alpha.count=T,
                add.points=T,
                fill.colors=c(abb.col[1], abb.col[5]))
  qtl.hm

```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
  
  qtl.hm.svm <- abbHeatMap(str.data.ic,
                   x.field='occ.qtl',
                   y.field='rate.qtl',
                   pref.field='str.ext.pref',
                   svm=T, 
                   alpha.count=F,
                   add.points=T,
                   quantile=T,
                   fill.colors=c(abb.col[1], abb.col[5]))
  qtl.hm.svm

```


```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  svm.rate <- makeSVM(str.data.ic,
                     x.field='occ.rate',
                     y.field='nightly.rate',
                     z.field='str.act.pref',
                     svm.type='C-svc',
                     svm.kernel='polydot',
                     poly.degree=4,
                     expand.factor=100)
  
  svm.qtl <- makeSVM(str.data.ic,
                      x.field='occ.qtl',
                      y.field='rate.qtl',
                      z.field='str.act.pref',
                      svm.type='C-svc',
                      svm.kernel='polydot',
                      poly.degree=4,
                      expand.factor=100)
  
  market.ratio <- data.frame(type=c('rate', 'qtl'),
                             actual=rep(mean(str.data.ic$str.act.pref), 2),
                             fitted=c(mean(svm.rate$orig$fitted),
                                      mean(svm.qtl$orig$fitted)),
                             svm=c(mean(svm.rate$pred$pred),
                                   mean(svm.qtl$pred$pred)))
```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  mod.ext.str <- glm(str.ext.pref~type+as.factor(bedbath),
                     family=binomial(link='logit'),
                     data=str.data.ic)
  mod.pot.str <- glm(str.pot.pref~type+as.factor(bedbath),
                     family=binomial(link='logit'),
                     data=str.data.ic)
```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  mod.ext.loc <- glm(str.ext.pref~type+as.factor(bedbath)+
                                  sub.mrkt,
                     family=binomial(link='logit'),
                     data=str.data.ic)
  mod.pot.loc <- glm(str.pot.pref~type+as.factor(bedbath)+
                                  sub.mrkt,
                     family=binomial(link='logit'),
                     data=str.data.ic)
```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  mod.ext.host <- glm(str.ext.pref~type+as.factor(bedbath)+
                        sub.mrkt+as.factor(host.type)+
                        I(max.guests/bedrooms)+min.stay+
                        I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                      family=binomial(link='logit'),
                      data=str.data.ic)
  mod.pot.host <- glm(str.pot.pref~type+as.factor(bedbath)+
                        sub.mrkt+as.factor(host.type)+
                        I(max.guests/bedrooms)+min.stay+
                        I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                      family=binomial(link='logit'),
                      data=str.data.ic)
```


```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  mod.ext.str <- lm(str.ext.prem~type+as.factor(bedbath),
                    data=str.data.ic)
  mod.pot.str <- lm(str.pot.prem~type+as.factor(bedbath),
                    data=str.data.ic)
  
```


```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  mod.ext.host.prem <- lm(str.ext.prem~type+as.factor(bedbath)+
                        sub.mrkt+
                        I(max.guests/bedrooms)+min.stay+
                        I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                      data=str.data.ic)
  mod.pot.host.prem <- lm(str.pot.prem~type+as.factor(bedbath)+
                        sub.mrkt+
                        I(max.guests/bedrooms)+min.stay+
                        I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                      data=str.data.ic)
```


```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  ps <- which(str.data.ic$host.type == 'Profit Seeker')
  os <- which(str.data.ic$host.type == 'Opportunistic Sharer')
  mu <- which(str.data.ic$host.type == 'Multi-Platform User')
  un <- which(str.data.ic$host.type == 'Unknown')
  
  
  mod.ext.ps <- glm(str.pot.pref~type+as.factor(bedbath)+
                    sub.mrkt+
                    I(max.guests/bedrooms)+min.stay+
                    I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                 family=binomial(link='logit'),
                 data=str.data.ic[ps,])
  
  
  mod.ext.os <- glm(str.pot.pref~type+as.factor(bedbath)+
                    sub.mrkt+
                    I(max.guests/bedrooms)+min.stay+
                    I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                 family=binomial(link='logit'),
                 data=str.data.ic[os,])
  
  mod.ext.mu <- glm(str.pot.pref~type+as.factor(bedbath)+
                    sub.mrkt+
                    I(max.guests/bedrooms)+min.stay+
                    I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                 family=binomial(link='logit'),
                 data=str.data.ic[mu,])
  
  mod.ext.un <- glm(str.pot.pref~type+as.factor(bedbath)+
                    sub.mrkt+
                    I(max.guests/bedrooms)+min.stay+
                    I(cancel.policy=='Flexible') + I(cancel.policy=='Strict'),
                 family=binomial(link='logit'),
                 data=str.data.ic[un,])
  
```


### Moving Window Logit

To better capture the spatial variation in the logit model results, we set up a moving window logit model that estimates a different model at each estimation point on the map.  Before beginning, we import a new suburbs shapefile and trim it to those suburbs with Airbnb properties. 
```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 suburbs.shp <- readShapePoly(paste0(data.path, 'geographic/melbSuburbs.shp'),
                              proj4string=CRS("+init=epsg:4283"),
                              delete_null_obj=TRUE)

 ssubs <- table(str.data.ic$suburb)
 s.subs <- subs[subs$id %in% names(ssubs),]
 s.suburbs <- suburbs.shp[suburbs.shp@data$NAME_2006 %in% names(ssubs),]
 sssubs <- fortify(s.suburbs)
 
```

Next we set up the prediction points.  We drap a grid over the entire area and use those points for prediction points. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 # Min, Max and Range
 xmin <- min(s.subs$long)
 xmax <- max(s.subs$long)
 ymin <- min(s.subs$lat)
 ymax <- max(s.subs$lat)
 xrange <- xmax-xmin
 yrange <- ymax-ymin
 
 # Set Scale
 scale <- mean(xrange, yrange)/100
 
 # Create estimation points
 est.data <- str.data.ic
 est.points <- createGridPoints(s.suburbs, scale, T)

```

We then specify the logistic regression model and set the moving window bandwidth. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 ## Set model specification  
 
 pot.mod.spec <- str.pot.pref ~ type + as.factor(bedbath) + 
   I(max.guests / bedrooms) + min.stay + 
   I(cancel.policy == 'Flexible') + 
   I(cancel.policy == 'Strict')
 
 ext.mod.spec <- str.ext.pref ~ type + as.factor(bedbath) + 
   I(max.guests / bedrooms) + min.stay + 
   I(cancel.policy == 'Flexible') + 
   I(cancel.policy == 'Strict')


 ## Set bandwidth
 
 k <- 400

```

The results are estimated with the custom MWL function

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 pot.results.all <- mwl(est.data, 
                        est.points, 
                        pot.mod.spec, 
                        k)

 ext.results.all <- mwl(est.data, 
                        est.points, 
                        ext.mod.spec, 
                        k)
 
 
  pot.results.ps <- mwl(est.data[ps, ], 
                        est.points, 
                        pot.mod.spec, 
                        k)
   pot.results.os <- mwl(est.data[os, ], 
                        est.points, 
                        pot.mod.spec, 
                        k)
 
   pot.results.mu <- mwl(est.data[mu, ], 
                        est.points, 
                        pot.mod.spec, 
                        k)
 
   pot.results.un <- mwl(est.data[un, ], 
                        est.points, 
                        pot.mod.spec, 
                        k)
 

   ext.results.ps <- mwl(est.data[ps, ], 
                        est.points, 
                        ext.mod.spec, 
                        k)
   ext.results.os <- mwl(est.data[os, ], 
                        est.points, 
                        ext.mod.spec, 
                        k)
 
   ext.results.mu <- mwl(est.data[mu, ], 
                        est.points, 
                        ext.mod.spec, 
                        k)
 
   ext.results.un <- mwl(est.data[un, ], 
                        est.points, 
                        ext.mod.spec, 
                        k)
 

```

Coefficents are extracted and put into a data.frame


MAKE A FUNCTION BELOW HERE

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

extrMWLCoef <- function(mwl.results,
                        est.points,
                        names.coef){
 
 coef.names <- rownames(mwl.results[[1]])
 
 # Create a list to capture
 coef.list <- list()
 
 # Create a data.frame to capture
 coef.df <- data.frame(lat=est.points@coords[,2],
                       long=est.points@coords[,1])
 
 # Loop through and extract coefficients
 for(cn in 1:length(coef.names)){
   coef.list[[cn]] <- lapply(mwl.results, getMWLCoef, coef=coef.names[cn])
   coef.df[ ,ncol(coef.df) + 1] <- unlist(coef.list[[cn]])
 }
 
 # Add plottable names
 colnames(coef.df)[3:13] <- names.coef
 
 return(coef.df)

}
```



```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

x.names <- c('intercept', 'house', 'bb11', 'bb21', 'bb31',
                              'bb32', 'bb42', 'guest', 'minstay', 'flex', 'strict')

pra.coef <- extrMWLCoef(pot.results.all,
                        est.points,
                        x.names)
era.coef <- extrMWLCoef(ext.results.all,
                        est.points,
                        x.names)
prp.coef <- extrMWLCoef(pot.results.ps,
                        est.points,
                        x.names)
pro.coef <- extrMWLCoef(pot.results.os,
                        est.points,
                        x.names)
prm.coef <- extrMWLCoef(pot.results.mu,
                        est.points,
                        x.names)
pru.coef <- extrMWLCoef(pot.results.un,
                        est.points,
                        x.names)
erp.coef <- extrMWLCoef(ext.results.ps,
                        est.points,
                        x.names)
ero.coef <- extrMWLCoef(ext.results.os,
                        est.points,
                        x.names)
erm.coef <- extrMWLCoef(ext.results.mu,
                        est.points,
                        x.names)
eru.coef <- extrMWLCoef(ext.results.un,
                        est.points,
                        x.names)
```

Finally, these coefficients are converted to a surface. 

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

makeMWLSurfs <- function(mwl.coefs,
                         est.points){

  # Make capture list
  surf.list <- list()
  
  mwl.coefs <- mwl.coefs[ ,!names(mwl.coefs) %in% c('lat', 'long')]
 
 # Create surfaces
  for(sl in 1:ncol(mwl.coefs)){
   
   # If NAs
   to.cut <- which(is.na(mwl.coefs[,sl]))
   if(length(to.cut) > 0){
     surf.points <- est.points[-to.cut,]
     surf.value <- mwl.coefs[-to.cut, sl]
   } else {
     surf.points <- est.points
     surf.value <- mwl.coefs[ , sl]
   }
   
   # Surface estimation
   surf.list[[sl]] <- point2Surface(surf.points, 
                                    surf.value,
                                    .01, 
                                    1.5)
  }
  
  names(surf.list) <- names(mwl.coefs)

return(surf.list)    
}

```

```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

pra.surfs <- makeMWLSurfs(pra.coef,
                          est.points)
era.surfs <- makeMWLSurfs(era.coef,
                          est.points)


prp.surfs <- makeMWLSurfs(prp.coef,
                          est.points)
pro.surfs <- makeMWLSurfs(pro.coef,
                          est.points)
prm.surfs <- makeMWLSurfs(prm.coef,
                          est.points)
pru.surfs <- makeMWLSurfs(pru.coef,
                          est.points)


erp.surfs <- makeMWLSurfs(erp.coef,
                          est.points)
ero.surfs <- makeMWLSurfs(ero.coef,
                          est.points)
erm.surfs <- makeMWLSurfs(erm.coef,
                          est.points)
eru.surfs <- makeMWLSurfs(eru.coef,
                          est.points)

```

