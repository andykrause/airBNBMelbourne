---
title: "Data Preparation, Integration and Cleaning"
output:
  pdf_document: default
  html_notebook: default
  html_document: default
editor_options: 
  chunk_output_type: console
---

### Introduction

This file details the initial data preparation and cleaning that we have applied to the AirBNB nightly data from www.AirDNA.co as well as to the long-term rental data from Australia Property Monitors (APM).  Both datasets have had some initial pre-processing done, the details of which are found in **1_str_preprocess.R** and **2_ltr_preprocess.R**. 

&nbsp;
&nbsp;

### Preliminary Commands

&nbsp;

We begin with a number of preliminary commands.  First we load all of the necessary R libraries for this analysis. 

```{r load_libraries, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}

  library(spdep)
  library(maptools)
  library(gstat)
  library(ggplot2)
  library(geosphere)
  library(ggmap)
  library(xtable)
  library(plyr)
  library(sp)
  library(rgeos)
  library(reshape2)
  library(stringr)
  library(RColorBrewer)
  library(Hmisc)
  library(dplyr)
  library(multidplyr)
  library(lubridate)
  library(tidyverse)
  library(sf)

```

We then set the paths to the data and the code, conditional on which of the authors is running the analysis.

```{r set_paths, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}

  data_path <- file.path('c:', 'dropbox', 'research', 'airBNB', 'data')
  code_path <- file.path('c:', 'code', 'research', 'airbnbmelbourne')
  fig_path <- file.path('c:', 'dropbox', 'research', 'airBNB', 'figures')

```

Next, we source the necessary custom code files for the analysis.  

```{r source_files, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}

  source(file.path(code_path, 'functions', 'abb_Functions.R'))

#
#  # Other custom files
# 
#   if(offline){
# 
#     source(file.path(code_path, 'tools', 'dataVizTools', 'ggPlotTools.R'))
#     source(file.path(code_path, 'tools', 'datamgmttools', 'dataMungeTools.R'))
#     source(file.path(code_path, 'tools', 'spatialTools', 'spatialLogitModels.R'))
#     source(file.path(code_path, 'tools', 'spatialTools', 'point2surface_Tools.R'))
#     
#   } else {
#     
#   source(paste0('https://raw.githubusercontent.com/andykrause/dataVizTools',
#                 '/master/ggPlotTools.R'))
#   source(paste0('https://raw.githubusercontent.com/andykrause/datamgmttools',
#                 '/master/dataMungeTools.R'))
#   source(paste0('https://raw.githubusercontent.com/andykrause/spatialTools',
#                 '/master/spatialLogitModels.R'))
#   source(paste0('https://raw.githubusercontent.com/andykrause/spatialTools',
#                 '/master/point2surface_Tools.R'))
# 
#   }
```

### Constants and Parameters

We then set the constants used in this study:
 
1. **Exchange rate**: The Airbnb rates are provided in US dollars.  We convert these to Australian dollars based on the average exchange rate over the Sep 1 2015 to Aug 30 2015 period, or about 1.32 Australian dollars to 1 US dollar.
 
```{r set_constants, message=FALSE, warning=FALSE, comment=FALSE, echo=TRUE, results='hide'}
 
 exch_rate <- 1.32  

```

2. **Date of Purchase**: In our analyzis we assume a date on which the decision to Airbnb or to enter into a long-term rental strategy is undertaken.  We set this to September 1, 2015. 

```{r set_date}
  
  decision_date <- lubridate::as_date('2015-09-01')
  
```

3. Colors for visualizations.  We use the official Airbnb palette of colors for our ongoing data vizualizations. 

 
```{r set_colors, message=FALSE, warning=FALSE, comment=FALSE, echo=FALSE}
 
 # Set all colors

  abb_colors.names=c('rausch', 'hackberry', 'kazan', 'babu', 'lima', 'beach',
                     'ebisu', 'tirol', 'foggy', 'hof')
  abb_col <- c(rgb(250,88,99, maxColorValue=255), rgb(139,14,82, maxColorValue=255),
               rgb(0,117,140, maxColorValue=255), rgb(4,211,191, maxColorValue=255),
               rgb(77,226,110, maxColorValue=255), rgb(252,179,14, maxColorValue=255),
               rgb(249,177,139, maxColorValue=255), rgb(191,166,100, maxColorValue=255),
               rgb(156,161,155, maxColorValue=255), rgb(86,94,97, maxColorValue=255))

 # Set specific colors

  str_col <- abb_col[1]
  ltr_col <- abb_col[3]

```

## Loading data

&nbsp;

Next we load in the raw data.  The short-term rental (Airbnb) data is found in two separate files, one providing information on the property itself and one providing a daily record of bookings.

```{r load_str_data, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str_tdf <- readRDS(file.path(data_path, 'prepared', 'str_data.RDS'))

  ltr_tdf <- readRDS(file.path(data_path, 'prepared', 'ltr_data.RDS'))

```
 
And, finally, we load three GIS shapefiles.  The first two denote suburb and Statistical Area 1 (sa1) boundaries in the Melbourne area. We also load a shapefile that contains the location of the beach areas along Port Phillip Bay.^[Only those east of the mouth of Yarra River as those to the west are primarily industrial land.]  After we load each we convert the names of the data fields to lower case for easier use in future coding.

```{r load_sp_data, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  sub_sf <- sf::st_read(file.path(data_path, 'geographic', 'melbSuburbs.shp')) %>%
    st_transform(crs=4283)
  sa1_sf <- sf::st_read(file.path(data_path, 'geographic', 'sa1s.shp')) %>%
    st_transform(crs=4283)
  beach_sf <- sf::st_read(file.path(data_path, 'geographic','portPhillipBeach.shp')) %>%
    st_transform(crs=4283)

```
 
## Data Preparation
 
&nbsp;
 
In this section we remove, convert and/or transform a number of data fields. We also remove observations if they are missing critical data or fall outside of the scope of our research question. 

### Trim by Time
 
Next we filter the observations by time.  Our hypothetical simulated decision is that of an investor who purchases a property on September 1, 2015 and must decide on traditional long term rental versus an AirBNB, short term rental approach to generating income.  To determine the likely long term rental rate for any given property, we will use the observed rental transactions from the market from September 1, 2014 to August 31, 2015.  Taking the AirBNB approach allows the owner to change rates over time and is subjected to daily changes in the market (supply and demand factors).  In this simulated example we will use AirBnB data from September 1, 2015 to August 31, 2016 to represent the actual AirBNB market conditions over the time period in question.  Another reason for using these two period of data is that the AirBNB data has missing daily values prior to September 1, 2015.  While we have imputed these missing daily observations, we hold the actual observed values to be of greater accuracy and have designed the initial simulated example to take advantage of the full observed set. 
 
Before we begin the filter process, we initial the data cleaning counter -- a small function that keeps track of how many observations we remove.  

```{r initialCC, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

   setCleanCount()

```

We then clip by time.  For the short-term data we will consider any Airbnb property that had at least 6 months worth of listing time on the portal during the 12-month study period
 
```{r clip_time, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE}
  
  # Limit short term data
   
  # Trim properties by min and max date
  str_tdf <- str_tdf %>%
    dplyr::filter((max_date - min_date) >= 178) %>%
    dplyr::filter((max_date >= (decision_date + 182) &
                    min_date <= (decision_date + 182)))

   # Trim actual nightly observation by the decision date
   str_tdf <- str_tdf %>% 
     mutate(daily_data = map(daily_data, ~filter(., date >= decision_date)))

  # Limit long term data
  ltr_tdf <- ltr_tdf %>% 
     mutate(trans_data = map(trans_data, ~filter(., (date <= decision_date - 1) & 
                                                     date >= decision_date - 365)))
 # Count cleaning

  countCleaning('time')

```
 
Next we add a monthly variable to the data for use in future modeling exercises. 
 
```{r add_month, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  # Short term data
   str_tdf <- str_tdf %>% 
     mutate(daily_data = map(daily_data, 
                             ~mutate(., month = paste0(lubridate::year(date), "_",
                                                       lubridate::month(date)))))
  # Long term data
  ltr_tdf <- ltr_tdf %>% 
     mutate(trans_data = map(trans_data, 
                             ~mutate(., month = paste0(lubridate::year(date), "_",
                                                       lubridate::month(date)))))
  
```

### Standardize Property Types

&nbsp;

AirBNB units are classified into 19 different property type.  The most common are Apartments and Houses, the least common are Igloo, Tent, Treehouse and Yurt^[Property types are owner/lister defined, therfore it is likely that the Igloo, at the very least, is not a completely true representation of the property type]. For the sake of this analysis, we will collapse these twenty types into three types:

1. **House**:  Includes properties labeled 'House' or 'Townhouse'
2. **Apartment**: Includes properties labeled as 'Apartment' or 'Condominium'
3. **Other**: Includes properties labeled as 'Bed & Breakfast', 'Boat', 'Bungalow', 'Cabin', 'Camper/RV', 'Chalet', 'Dorm', 'Earth House', 'Hut', 'Igloo', 'Loft', 'Other', 'Tent', 'Treehouse', Villa' and 'Yurt.

Within the long-term rental data, property types fall into eight categories.  Like the AirBNB data we group these into three categories matching as best as possible to the AirBNB categories:

1. **House**:  Includes properties labeled 'Duplex', 'House', 'Terrace' or 'Townhouse'
2. **Apartment**: Includes properties labeled as 'Unit' or 'Studio'
3. **Other**: Includes properties labeled as 'Semi' and 'Villa'

Part of the difficulty in perfectly mapping property types from these two datasets is due to the fact that the long-term data uses Australian terms while the AirBNB data conforms to North American lexicon.  This is most apparent when talking about apartment dwellings.  In Australia these are referred to as Units, while in North American they are referred to as Apartments or Condominiums (depending on ownership structure).  Additionally, Terrace homes are very common in many of the older suburbs of Melbourne and would be considered Rowhouses or, likely, Townhomes in the North American context. 
 
We then create a new variable in each dataset and give each one of the three categories discussed above.
 
```{r fix_type, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
 
  # Short Term data  

  str_tdf <- str_tdf %>%
    dplyr::mutate(type = 'Other')
  str_tdf$type[str_tdf$property_type %in% 
               c('Apartment', 'Condominium', 'Loft')] <- 'Apartment'
  str_tdf$type[str_tdf$property_type %in% c('House', 'Townhouse', 'Villa')] <- 'House'
 
  # Long Term data  
 
  ltr_tdf <- ltr_tdf %>%
    dplyr::mutate(type = 'Other')
  ltr_tdf$type[ltr_tdf$property_type %in% c('Duplex', 'House',
                                             'Terrace', 'Townhouse', 'Villa')] <- 'House'
  ltr_tdf$type[ltr_tdf$property_type %in% c('Studio', 'Unit')] <- 'Apartment'
 
```
 
As the chart below show, the **Other** category only makes up a very small percentage of the properties in both the short and long term market, especially in the long-term market.  Additionally, a good portion of the **Others** in the Airbnb data are Bed & Breakfast units, a use which doesn't fit with our research question.  As a result, we remove the 'Others' from both the Airbnb and the long term rental data. 
 
```{r plot_type_comp, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE, fig.height=4}
 
   # Create Airbnb plot
 
   str_types <- ggplot(str_tdf, aes(x=type)) + 
     geom_bar(color=str_col, fill=str_col) +
     xlab('\nProperty Type\n') + 
     ggtitle('\nShort Term Rentals\n')  +
     ylab('# of Properties\n') +
     theme(plot.title = element_text(hjust = 0.5)) 

  # Create long term rental plot

  ltr_types <- ggplot(ltr_tdf, aes(x=type)) +
    geom_bar(color=ltr_col, fill=ltr_col) +
    xlab('\nProperty Type\n') +
    ggtitle('\nLong Term Rentals\n')  +
    ylab('# of Properties\n') +
    theme(plot.title = element_text(hjust = 0.5))

  str_types
  ltr_types
  
  # Output plots
  # png(file=paste0(fig.path, 'dataclean_proptype.png'), width = 480, height = 280,
  #     bg='transparent')
  #  ggMultiPlots(str_types, ltr_types, cols=2)
  # dev.off()
# 
#   save(str.types, file=paste0(fig.path, 'strtypes.RData'))
#   save(ltr.types, file=paste0(fig.path, 'ltrtypes.RData'))

```

```{r remove_others, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE, fig.height=4}

   str_tdf <- str_tdf %>% dplyr::filter(type != 'Other')
   ltr_tdf <- ltr_tdf %>% dplyr::filter(type != 'Other')

   # Count Cleaning
   countCleaning('property.type')

```

Next, for the short term rentals properties can be listed as one of three types relating to the extent of the property which is able to be booked:
 
1. **Entire Home/Apt**: The entire home or apartment is available
2. **Private Room**: One room within a house or apartment is available
3. **Shared Room**: A bed within a room shared by another occupant(s) is available
 
As long-term rentals do not offer **Private Room** or **Shared Room** options^[Our dataset does not include rooming houses, purpose built student accomodations and other types of rental which may offer private or shared room options] and our purpose here is a comparison of long and short term returnw, we remove all short term properties that do not lease the entire home/apt. Unfortunately, this filter does remove about 40% of the short term data, however, given the research question it is unavoidable. 
 
```{r ltype_comp, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE, fig.height=4}
 
   # Fix data types and names
   str_tdf <- str_tdf %>%
     dplyr::mutate(listing_type = as.character(listing_type),
                   listing_type = if_else(listing_type == 'Entire home/apt', 
                                          'Entire home', listing_type)) 

   list_types <- ggplot(str_tdf, aes(x=listing_type)) + 
      geom_bar(color=str_col, fill=str_col) +
      xlab('\nListing Type\n') +
      ggtitle('\nShort Term Rentals by Listing Type\n')  +
      ylab('# of Properties\n') +
    theme(plot.title = element_text(hjust = 0.5))

  # # Make Plot
  # png(file=paste0(fig.path, 'dataclean_listtype.png'), width = 480, height = 280,
  #     bg='transparent')
  # 
  #   list.types
  # 
  # dev.off()
  # 
  # save(list.types, file=paste0(fig.path, 'listtypes.RData'))

```

```{r keep_entire_home, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str_tdf <- str_tdf %>% 
    dplyr::filter(listing_type == 'Entire home')

  # Count cleaning
  countCleaning('listing_type')

```
 
## Structural Characteristics
 
&nbsp;
 
In this section we transform and filter based on the structural characteristics of the properties. 
 
### Bedrooms
 
We start by looking at bedrooms. We begin by removing all properties that are missing bedrooms information or have a likely data error in this fields (more than 14 bedrooms). We then plot the distribution of diffeltr bedrooms counts.  From this point onwards we bifurcate our analysis between houses and apartments as the markets (prices, rates, and properties) differ between the two property types. 
 
```{r bed_fltr, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
 
  # Remove missing and data errors
 
   # Long term data
   ltr_tdf <- ltr_tdf %>%
     dplyr::filter(!is.na(bedrooms)) %>%
     dplyr::filter(bedrooms <= 10)
 
   # Short term data
   str_tdf <- str_tdf %>%
     dplyr::filter(!is.na(bedrooms)) %>%
     dplyr::filter(bedrooms <= 10)
 
```
 
```{r bed_fltr2, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE, fig.height=5}
 
  # Build long term bar plot
 
    ltrbed <- ggplot(ltr_tdf, aes(x=bedrooms)) + 
     geom_bar(fill=ltr_col, color=ltr_col) +
     facet_wrap(~type,scales='free_y') +
     scale_x_continuous(labels=1:10, breaks=1:10)+
     xlab('\nBedrooms\n') +
     scale_y_continuous(labels=c(0,10000,20000), 
                        breaks=c(0,10000,20000))+
     ylab('') +
     ggtitle('Bedrooms in Long Term Rentals') +
     theme(plot.title = element_text(hjust = 0.5)) 
  
  # Build short term bar plot
 
   strbed <- ggplot(str_tdf, aes(x=bedrooms)) + 
     geom_bar(fill=str_col, color=str_col) +
     facet_wrap(~type,scales='free_y') +
     scale_x_continuous(labels=0:10, breaks=0:10) +
     xlab('\nBedrooms\n') +
     ylab('') +
     ggtitle('Bedrooms in Short Term Rentals') +
     theme(plot.title = element_text(hjust = 0.5)) 
  
#   # Make Plot
#   png(file=paste0(fig.path, 'dataclean_bedcount.png'), width = 480, height = 280, 
#       bg='transparent')
#     ggMultiPlots(strbed, ltrbed, cols=1)
#   dev.off()
#   
#   save(ltrbed, file=paste0(fig.path, 'ltrbed.RData'))
#   save(strbed, file=paste0(fig.path, 'strbed.RData'))
 
```
 
For both short and long term rentals we see that most apartments have less than 4 bedrooms and houses less than 5.  We filter the data accordingly. Additionally, note that short term rentals consider studio apartments to be 0 bed units while the long term data considers these as 1 bedroom. We convert the 0 bed short term units to 1 bed units.   
 
```{r bed_fltr3, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
 
  # Remove all with more than 4 beds for house, 3 beds for apt and convert studio to 1 bed
 
   str_df <- str_tdf %>% 
     dplyr::filter(bedrooms < 5) %>%
     dplyr::filter(type == 'House' | (type == 'Apartment' & bedrooms < 4)) %>%
     dplyr::mutate(bedrooms == if_else(bedrooms == 0, 1L, bedrooms))
   
   ltr_df <- ltr_tdf %>% 
     dplyr::filter(bedrooms < 5) %>%
     dplyr::filter(type == 'House' | (type == 'Apartment' & bedrooms < 4)) %>%
     dplyr::mutate(bedrooms == if_else(bedrooms == 0, 1, bedrooms))
  
 # Count Data Cleaning
 countCleaning('bedrooms')
 
```
 
### Bathrooms
 
We then turn to bathrooms, starting by looking at the distribution of baths between short/long and apt/house.  
 
```{r bath_fltr, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
 
  # Remove missing data
  ltr_tdf <- ltr_tdf %>% dplyr::filter(!is.na(baths))
  str_tdf <- str_tdf %>% dplyr::filter(!is.na(baths))

```
 
```{r bath_fltr2, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE, fig.height=5}
 
  # Build long term plot
 
   ltbath <- ggplot(ltr_tdf, aes(x=baths)) + 
     geom_bar(fill=ltr_col, color=ltr_col) +
     facet_wrap(~type) +
     scale_x_continuous(labels=1:8, breaks=1:8)+
     xlab('\nBathrooms\n') +
     ylab('') +
     ggtitle('Bathrooms in Long Term Rentals') +
     theme(plot.title = element_text(hjust = 0.5))

 # Build short term plot

  stbath <- ggplot(str_tdf, aes(x=baths)) +
    geom_bar(fill=str_col, color=str_col) +
    facet_wrap(~type, scales='free_y') +
    scale_x_continuous(labels=0:8, breaks=0:8)+
    xlab('\nBathrooms\n') +
    ylab('') +
    ggtitle('Bathrooms in Short Term ltrals') +
    theme(plot.title = element_text(hjust = 0.5))

#  # Make Plots  
#   png(file=paste0(fig.path, 'dataclean_bathount.png'), width = 480, height = 280, 
#       bg='transparent')
#   
#     ggMultiPlots(stbath, ltbath, cols=1)
#     
#   dev.off()
#    
#   save(ltbath, file=paste0(fig.path, 'ltrbath.RData'))
#   save(stbath, file=paste0(fig.path, 'strbath.RData'))
  
```
 
Here we see that nearly all properties have 3 or fewer bathrooms and we filter the data accordingly. A few short term properties state no baths, which is likely an error so we remove these as well. Also, here we notice that the short term data gives bathrooms in halves, while the long term data presents baths in whole numbers.  We round the baths up to whole integers. 
 
```{r bath_fltr3, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  str_tdf <- str_tdf %>%
    dplyr::mutate(bathrooms = round(bathrooms + .01, 0)) %>%
    dplyr::filter(bathrooms < 4 & bathrooms > 0) 

  ltr_tdf <- ltr_tdf %>%
    dplyr::rename(bathrooms = baths) %>%
    dplyr::filter(bathrooms < 4 & bathrooms > 0)

   # Count cleaning
   countCleaning('baths')
   
```
 
### Bed/Bath Combination
 
In addition to looking at bedrooms and bathrooms as separate dimensions of properties, they can also be considered together.  In other words, it is very common in the industry (and when looking for a short term ltral) to specify searches by bed/bath combination for obvious reasons -- 1 bedroom with 3 baths is inefficient and 4 bedrooms with 1 bath is uncomfortable.  As a result we examine the combinations of the two. 
 
```{r filtBB, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
 
 # Create combination variable
  str_tdf <- str_tdf %>% 
    dplyr::mutate(bedbath = paste0(bedrooms, "_", bathrooms))

  ltr_tdf <- ltr_tdf %>% 
    dplyr::mutate(bedbath = paste0(bedrooms, "_", bathrooms))

```

```{r filtBB2, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE, fig.height=5}

 # Make long term plot

  ltbb <- ggplot(ltr_tdf, aes(x=bedbath)) +
    geom_bar(fill=ltr_col, color=ltr_col) +
    xlab('\nBed/Bath Combo\n') +
    ylab('Number of Properties\n') +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ggtitle('Long Term Rentals') +
    facet_wrap(~type, scales='free_y')+
    theme(plot.title = element_text(hjust = 0.5))

 # Make short term plots

  stbb <- ggplot(str_tdf, aes(x=bedbath)) +
    geom_bar(fill=str_col, color=str_col) +
    xlab('\nBed/Bath Combo\n') +
    ylab('Number of Properties\n') +
    ggtitle('Short Term Rentals') +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    facet_wrap(~type, scales='free_y')+
    theme(plot.title = element_text(hjust = 0.5))

#  # Make Plots  
#   png(file=paste0(fig.path, 'dataclean_bedbath.png'), width = 480, height = 280, 
#       bg='transparent')
   
#     ggMultiPlots(ltbb, stbb, cols=1)
 
#   dev.off()  
   
#   save(ltbb, file=paste0(fig.path, 'ltrbb.RData'))
#   save(stbb, file=paste0(fig.path, 'strbb.RData'))
 
     
```
 
From this analysis we see that there are 6 combinations that make up most all properties:  1bed/1bath, 2/1, 2/2, 3/1, 3/2 and 4/2. We filter the data to these combinations.  We also combine type and bed bath combination to create a 'product'. 
 
```{r filtBB3, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

 # Set level of acceptable combinations

  acc_bb <- c('1_1', '2_1', '2_2', '3_1', '3_2', '4_2')

 # Filter data
  str_tdf <- str_tdf %>%
    dplyr::filter(bedbath %in% acc_bb) %>%
    dplyr::mutate(product = paste0(substr(type, 1, 1), "_", bedbath))
  
  ltr_tdf <- ltr_tdf %>%
    dplyr::filter(bedbath %in% acc_bb) %>%
    dplyr::mutate(product = paste0(substr(type, 1, 1), "_", bedbath))

 # Count Cleaning

  countCleaning('bedbath')

```
 
## Rates and Rental values
 
We now turn to filtering by the prices -- the nightly rates and weekly rental values.  We start by removing observations missing price data. 
 
```{r ltprice_fltr, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}

  ltr_tdf <- ltr_tdf %>% 
     mutate(trans_data = map(trans_data, ~filter(., (date <= decision_date - 1) & 
                                                     date >= decision_date - 365)))

   ltr_tdf <- ltr_tdf %>% dplyr::filter(!is.na(price))
   str_tdf <- str_tdf %>% dplyr::filter(!is.na(price))

   str_df <- str_df[!is.na(str_df$nightly.rate), ]

```
 
TODO:  At the end, filter all that have no observations in teh list-cols    
 
Next, we convert the Airbnb values to Australian dollars from US dollars using the exchange rate specified above (1.32).
# 
# ```{r exch_rate_adj, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#   # Property level data
# 
#   str_df$average.daily.rate <- str_df$average.daily.rate * exch.rate
#   str_df$nightly.rate <- str_df$nightly.rate * exch.rate
#   str_df$weekly.rate <- str_df$weekly.rate * exch.rate
#   str_df$monthly.rate <- str_df$monthly * exch.rate
#   
#   # Daily data
#   
#   daily_df$price <- daily_df$price * exch.rate
# 
# ```
# 
# Next we extract all of the daily reservation data for the reserved nightly. From this information we calculate the median nightly reservation price for each property and append it to the property level data. 
# 
# ```{r ltprice_fltr3, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#    # Get all of the reservations
#   resv.daily <- daily_df[daily_df$status == 'R', ]
# 
#   # Calculate the property specific median nightly rate
#   med.daily <- tapply2DF(resv.daily$price, resv.daily$property.id, median)
#   
#   # Add median rate to the property  
#   str_df$med.rate <- med.daily$Var[match(str_df$property.id, med.daily$ID)] 
#   
#   # Remove those with no valid median rate
#   str_df <- str_df[!is.na(str_df$med.rate), ]
#    
# ```
# 
# From these density plots we see that most long-term Rentals are greater than $200 and less than $1000 per week while most nightly rates are greater than $50 and less than $500 per night. We filter the data accordingly. 
# 
# ```{r ltprice_fltr2, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE}
# 
#   # ltr Plot
#   
#   ltr.plot <- ggplot(ltr_df, aes(x=event.price)) + 
#     geom_density(fill=ltr_col, alpha=.8) +
#     ylab('') +
#     xlab('Weekly Rental') + 
#     ggtitle('Long Term Rentals') + 
#     scale_x_continuous(limits=c(0, 1500)) +
#     theme(axis.title.y=element_blank(),
#           axis.text.y=element_blank(),
#           axis.ticks.y=element_blank()) +
#     theme(plot.title = element_text(hjust = 0.5))
# 
# 
#   # Nightly Rate plot
#   rate.plot <- ggplot(str_df, aes(x=nightly.rate)) + 
#     geom_density(fill=str_col, alpha=.8) + 
#     ylab('') +
#     xlab('Nightly Rate') +
#     ggtitle('Short Term Rentals') + 
#     scale_x_continuous(limits=c(0, 600)) +
#     theme(axis.title.y=element_blank(),
#           axis.text.y=element_blank(),
#           axis.ticks.y=element_blank()) +
#     theme(plot.title = element_text(hjust = 0.5))
# 
# 
# ```
# 
# ```{r ltprice_fltr2s, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE}
# 
#   png(file=paste0(fig.path, 'dataclean_rates.png'), width = 480, height = 280, 
#       bg='transparent')
#     
#     ggMultiPlots(ltr.plot, rate.plot, cols=2)
#   
#   dev.off()
#   
#   save(ltr.plot, file=paste0(fig.path, 'rentplot.RData'))
#   save(rate.plot, file=paste0(fig.path, 'rateplot.RData'))
# 
#   
# ```
# 
# ```{r ltprice_fltr33s, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE}
# 
#   ## Filter the long term data
# 
#   ltr_df <- ltr_df[ltr_df$event.price >= 200 & 
#                          ltr_df$event.price <= 1000, ]
# 
#   str_df <- str_df[str_df$med.rate >= 50 &
#                          str_df$med.rate <= 500, ]
# 
#   # Count Cleaning
#   countCleaning('rates.rents')
#   
# ```  
# 
# #### Observed Revenue
# 
# Our final data filtering considers the observed revenue of the properties. For the long-term rentals the observed revenue is the weekly rate multiplied by 52 minus the number of weeks the property was on the market.  In a number of extreme cases, time on market was extremely long and the total observed revenues very low. To remove these outlying observations, we filter out any properties with less than $5,000 in revenue.
# 
# For the short-term data, we first calculate the total number of bookings, the occupancy rate, blocked rate and proportion of the year over which the property was listed.  Using this data we sum up the total revenue from bookings. For properties that were not listed on the site for the entire year, we impute their annual revenue by dividing the actual revenue by the proportion of the year in which they were listed.^[Properties listed in summer, but not winter may be over imputed and vice versa, however, we expect the biases to cancel out over the entire sample.] Properties with no reserved bookings, and, therefore, no revenue, are removed.
# 
# Looking at the distribution of the revenues from each tenure type, we see that those for the long-term rentals are for more consistent, with the vast majority totaling between \$12,000 to \$30,000 per year (Figure 10).  Short term revenues range from neglible to highs of greater than \$80,000.  While this simple analysis does not control for location and product differences, it does highlight the fact that some Airbnb owners are likely making greater revenues than in long-term rentals, but that most are likely not. Also, the high number of very low yield Airbnb properties also suggests that some owners may not be focused on maximizing revenue, but instead prefer the flexibility of short-term leasing.
# 
# ```{r revdensity.plot, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=FALSE, fig.width=6,fig.height=3.5, fig.cap='Comparison of Revenue Distributions'}
# 
#  # Compute bookings count
# 
#   str_df$bookings <- round(str_df$total.days * 
#                                (1 - (str_df$block.rate + str_df$avail.rate)), 0)
#  
#  # Remove those with 0 
# 
#   str_df <- str_df[str_df$bookings > 0, ]
# 
#   str_df$gross.revenue <- (str_df$bookings * str_df$med.rate) 
#   ltr_df$gross.revenue <- ltr_df$event.price * (52 - ltr_df$dom / 7)
#  
#   str.small <- str_df[,c('baths', 'gross.revenue')]
#   str.small$tenure <- 'short-term'
#   ltr.small <- ltr_df[,c('baths', 'gross.revenue')]
#   ltr.small$tenure <- 'long-term'
#   all.small <- rbind(str.small, ltr.small)
# 
#   revdens <- ggplot(all.small, aes(x=gross.revenue, fill=tenure, color=tenure)) +
#     geom_density(alpha=.5) +
#     scale_fill_manual(values=c(ltr_col, abb_col)) +
#     scale_color_manual(values=c(ltr_col, abb_col)) +
#     ggtitle('Annual Revenues by Tenure Type') +
#     xlab('Annual Revenue') +
#     scale_x_continuous(breaks=c(seq(0,60000, by=20000)),
#                        labels=c('$0', '$20,000', '$40,000', '$60,000'))+
#     theme(legend.position='bottom',
#           legend.title = element_blank(),
#           plot.title = element_text(hjust = 0.5),
#           axis.text.y = element_blank(),
#           axis.ticks.y = element_blank(),
#           axis.title.y=element_blank()) +
#     coord_cartesian(xlim=c(0, 70000))
#   
# ```
# 
# ```{r revdensplot, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE}
# 
#   png(file=paste0(fig.path, 'revdens.png'), width = 480, height = 380, 
#       bg='transparent')
#     
#     revdens
#   
#   dev.off()
#   
#   save(revdens, file=paste0(fig.path, 'revdens.RData'))
#   
#   ltr_df <- ltr_df[ltr_df$dom <= 180, ]
#   
#     countCleaning('revenue')
#   
# ```
# 
# ### Locations and Submarkets
# 
# Location is clearly an important determinant in both the short and long term rental markets. At the broadest scale, the long-term Melbourne residential market is usually discussed in terms of Inner, Middle and Outer suburbs.  In general, prices are highest in the inner suburbs and lowest in the outer, with a number of exceptions in the high end neighborhoods in the east and southeastern areas of the middle suburbs.  Suburbs in Melbourne are much smaller than their North American counterparts.  The specific suburb of a property is the second, or finer scale, at which the market operates. The plot below shows the three large submarkets (Inner, Middle and Outer).
# 
# ```{r mappoints, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  # Convert shapefile to ggplot-able object
#   
#   # Fix lat/long
#  
#   # Limit to extent of data
#   sub.table <- table(ltr_df$suburb)
#   sub.table <- sub.table[sub.table != 0]
#   
#   # Clip to only those with a ltral observation
#   study.suburbs <- suburbs.shp[suburbs.shp@data$name_2006 %in% names(sub.table),]
#   
#   # Convert to an outer bound with holes
#   ss.bound <- gUnaryUnion(study.suburbs)
#   
#   # Remove holes from the shapefile
#   ssb <- slot(ss.bound, "polygons") 
#   holes <- lapply(ssb, function(x) sapply(slot(x, "Polygons"), 
#                                           slot, "hole"))
#   res <- lapply(1:length(ssb), function(i) slot(ssb[[i]], "Polygons")[!holes[[i]]]) 
#   IDs <- row.names(ss.bound) 
#   ssb.fill <- SpatialPolygons(lapply(1:length(res), function(i) 
#    Polygons(res[[i]], ID=IDs[i])), proj4string=CRS(proj4string(ss.bound))) 
#   
#   # Identify which suburbs all in area covered by outer bound
#   ss.in <- gIntersects(suburbs.shp, ssb.fill, byid=T)
#   study.suburbs <- suburbs.shp[which(ss.in), ]
#   
#   # Convert into an outer boundary with no holes
#   ss.bound.out <- gUnaryUnion(study.suburbs)
#   ssb.out <- slot(ss.bound.out, "polygons") 
#   holes <- lapply(ssb.out, function(x) sapply(slot(x, "Polygons"), 
#                                           slot, "hole"))
#   res.out <- lapply(1:length(ssb.out), 
#                     function(i) slot(ssb.out[[i]], "Polygons")[!holes[[i]]]) 
#   IDs <- row.names(ss.bound.out) 
#   ssb.fill.out <- SpatialPolygons(lapply(1:length(res.out), 
#                                          function(i) Polygons(res.out[[i]], 
#                                                               ID=IDs[i])),
#                                               proj4string=CRS(proj4string(ss.bound))) 
#   
#   # Convert into a ggplot-able format
#   subs <- fortify(study.suburbs, region='name_2006')
# 
#   # Add suburb category
#   subs$des <- suburbs.shp@data$suburbdesi[
#     match(subs$id, suburbs.shp@data$name_2006)]
# 
# ```
# 
# ```{r mappoints2, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE}
# 
#  ## Build the map object
# 
#   # Set colors
#   g_cols <- c('grey10', 'grey40', 'grey70')
# 
#   # Make map
#   loc.map <- ggplot() +
#     geom_polygon(data=subs, aes(x=long, y=lat, group=group, fill=des), alpha=.8) + 
#     scale_fill_manual(values=g_cols, labels=c('Inner      ',
#                                               'Middle      ',
#                                               'Outer')) +
#     geom_path(data=subs[subs$des=='Outer', ], 
#               aes(x=long, y=lat, group=group), col='white', size=.1,
#               linetype=1) +
#   
#     geom_path(data=subs[subs$des=='Middle', ], 
#               aes(x=long, y=lat, group=group), col='grey70', size=.1,
#               linetype=1) +
#     
#     geom_path(data=subs[subs$des=='Inner', ], 
#               aes(x=long, y=lat, group=group), col='grey40', size=.1,
#               linetype=1) +
#     
#     scale_x_continuous(limits=c(min(subs$long), max(subs$long))) +
#     scale_y_continuous(limits=c(min(subs$lat), max(subs$lat))) +
#     xlab('') + ylab('')+
#     theme(legend.position = 'bottom',
#           legend.title = element_blank(),
#           plot.title = element_text(hjust = 0.5),
#           panel.grid.major = element_blank(),
#           panel.grid.minor = element_blank(),
#           panel.background = element_rect(fill = "white"),
#           axis.text.x = element_blank(),
#           axis.text.y = element_blank(),
#           axis.ticks = element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.border = element_rect(colour = "black", fill=NA, size=1)) +
#     #ggtitle("Melbourne Suburb Classifications")+
#     theme(plot.title = element_text(hjust = 0.5))
# 
# ```
# 
# ```{r plot_loc_map, message=FALSE, warning=FALSE, comment=FALSE, cache=FALSE, echo=TRUE, fig.height=6}
#   png(file=paste0(fig.path, 'locationmap.png'), width = 480, height = 390, 
#       bg='transparent')
#   
#     loc.map
#     
#   dev.off()
#   
#   loc.map
#   
#   save(loc.map, file=paste0(fig.path, 'suburbMap.RData'))
# 
#     
# ```
# 
# It is likely that the short-term rental market follows a similar market hierarchy, however, we can imagine that a few different spatial features can influence the short-term market.  While there are many possible additional features, we consider two to be the most likely to influence rates or occupancy: 1) Proximity to beach; and 2) Proximity to key tourist activities and events.  Using the three broad submarkets from the long-term market (inner, middle and outer) we have created a five sub-market system as a starting point for spatially analysing short and long term ltrals in Melboure:
# 
# 1. Rural (Outer suburbs, not Beach)
# 2. Suburban (Middle suburbs, not Beach)
# 3. City (Inner Suburbs, not Beach, not Core)
# 4. City-Core (Select inner suburbs with tourist activities and near CBD)
# 5. Beach (Properties within 500m of Port Phillip Bay east of Yarra River)
# 
# We assign these designations by: 1) Adding suburb designations to the properties; 2) Assigning submarkets 1-4 based on suburb location; and 3) Indicating proximity to beach and labeling as 'Beach' submarket.  This process is repeated for both the short and long term data.  We also add the Statistical Area 1 code for each property for use in additional spatial modeling later on. Finally, we also remove any observations that fall outside of outer suburbs (the extent of the suburbs). 
# 
# We select the 18 suburbs below to represent the 'core' of the city.  The majority of tourist destinations and major events such as the Australian Open and the Grand Prix are located in these suburbs.  All are well serviced by public transportation and possess abundant amenties for tourists. 
# 
# ```{r core_suburbs, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  core.suburbs <- c('Albert Park', 'Carlton', 'Collingwood', 'Cremorne', 'Docklands',
#                    'East Melbourne', 'Fitzroy', 'Melbourne', 'Port Melbourne', 'Prahran',
#                    'Richmond', 'South Melbourne', 'South Yarra', 'Southbank', 'St Kilda',
#                    'St Kilda West', 'West Melbourne', 'Windsor')
# 
# ```
# 
# We then apply a 500 meter buffer to the beach along Port Phillip Bay. 
# 
# ```{r beachbuffer, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  # Determine centroid of study area
#  
#   latMid <- median(str_df$latitude)
#   longMid <- median(str_df$longitude)
# 
#  # Calculate Degress to Meters conversion 
#  
#   m.lat = 111132.954 - 559.822 * cos(2 * latMid) + 1.175 * cos(4 * latMid)
#   m.long = 111132.954 * cos (latMid)
#   m.conv <- mean(m.lat, m.long)
#  
#  # Create the beach buffer  
#   
#   beach.buffer <- gBuffer(beach.shp, byid=FALSE, width=500/m.conv)
# 
# ```
# 
# Next we assign the suburb, SA1, city-core and beach designations to observations in the Airbnb dataset.  
# 
# ```{r add_st_space, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  ## Short term data  
# 
#   # Convert to point shapefile
#   str.prop.shp <- SpatialPointsDataFrame(cbind(str_df$longitude,
#                                                str_df$latitude),
#                                          str_df,
#                                          proj4string=CRS("+init=epsg:4283")) 
# 
#   # Add suburb name 
#   spJoin <- over(str.prop.shp, suburbs.shp)
#   str_df$suburb <- as.character(spJoin$name_2006)
#   str_df$suburb[is.na(str_df$suburb)] <- 'missing'
# 
#   # Add suburb designation
#   str_df$sub.class <- as.character(spJoin$suburbdesi)
#   str_df$sub.class[is.na(str_df$sub.class)] <- 'missing'
#   
#   # Add SA1 designation
#   spJoin <- over(str.prop.shp, sa1s.shp)
#   str_df$sa1 <- spJoin$sa1_main11
#  
#   ## Add Beach Designation
#   spJoin <- over(str.prop.shp, beach.buffer)
#   str_df$beach <- ifelse(is.na(spJoin), 0 ,1)
#   
#   # Remove those missing a suburb classification (out of area)
#   str_df <- str_df[str_df$sub.class != 'missing', ]
#   str_df <- str_df[str_df$sa1 != 'missing', ]
# 
# ```
# 
# ```{r convert_st_subm, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  ## Add the submarket designations
# 
#   # Add individual classes
#   str_df$geo.mrkt <- 'rural'
#   str_df$geo.mrkt[str_df$sub.class == 'Middle'] <- 'suburban'
#   str_df$geo.mrkt[str_df$sub.class == 'Inner'] <- 'city'
#   str_df$geo.mrkt[str_df$suburb %in% core.suburbs] <- 'city-core'
#   str_df$geo.mrkt[str_df$beach == 1] <- 'beach'
#   
#   # Order the factors properly
#   str_df$geo.mrkt <- factor(str_df$geo.mrkt, 
#                               levels=c('city-core', 'city', 'suburban', 
#                                         'rural', 'beach'))
#   
# ```
# 
# Before we do the same for the long term data, we must remedy the fact that about 5% of the long term rental observations have missing latitude and longitude values.  Half of these do, however, have a lat/long value for the centroid of the street that the property faces.  To retain as many observations as possible in these intial steps for those properties that lack a specific lat/long value we apply the street centroid value.  For those without either (3% of the total) we remove them from the dataset at this point. 
# 
# ```{r fix_ltt_geo, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  # Label those missing lat/long  
# 
#   miss.LL <- which(is.na(ltr_df$latitude))  
# 
#  # Create a field to indicate the approximate matches  
# 
#   ltr_df$miss.LL <- 0
#   ltr_df$miss.LL[miss.LL] <- 1
# 
#  # Apply approximate match    
# 
#   ltr_df$latitude[miss.LL] <- ltr_df$street.latitude[miss.LL]
#   ltr_df$longitude[miss.LL] <- ltr_df$street.longitude[miss.LL]
# 
#  # Remove those still missing latitude data   
# 
#   ltr_df <- ltr_df[!is.na(ltr_df$latitude), ]
# 
# ```
# 
# Having fixed the missing lat/long issue, we then assign the suburb, SA1, city-core and beach designations to observations in the long term rental dataset.  
# 
# ```{r add_lt_space, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#   # Long term data  
# 
#   # Convert to point shapefile
# 
#   ltr.prop.shp <- SpatialPointsDataFrame(cbind(ltr_df$longitude,
#                                                ltr_df$latitude),
#                                          ltr_df,
#                                          proj4string=CRS("+init=epsg:4283")) 
# 
#   # Add suburb name 
#   
#   spJoin <- over(ltr.prop.shp, suburbs.shp)
#   ltr_df$suburb <- as.character(spJoin$name_2006)
#   ltr_df$suburb[is.na(ltr_df$suburb)] <- 'missing'
# 
#   # Add suburb designation
#   
#   ltr_df$sub.class <- as.character(spJoin$suburbdesi)
#   ltr_df$sub.class[is.na(ltr_df$sub.class)] <- 'missing'
#   
#   # Add SA1 designation
#   
#   spJoin <- over(ltr.prop.shp, sa1s.shp)
#   ltr_df$sa1 <- spJoin$sa1_main11
#  
#   ## Add Beach Designation
#   
#   spJoin <- over(ltr.prop.shp, beach.buffer)
#   ltr_df$beach <- ifelse(is.na(spJoin), 0 ,1)
#   
#   # Remove those missing a suburb classification (out of area)
#   
#   ltr_df <- ltr_df[ltr_df$sub.class != 'missing', ]
#   ltr_df <- ltr_df[ltr_df$sa1 != 'missing', ]
# 
# ```
# 
# ```{r convert_lt_subm, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  ## Add the submarket designations
# 
#   # Add individual classes
#   ltr_df$geo.mrkt <- 'rural'
#   ltr_df$geo.mrkt[ltr_df$sub.class == 'Middle'] <- 'suburban'
#   ltr_df$geo.mrkt[ltr_df$sub.class == 'Inner'] <- 'city'
#   ltr_df$geo.mrkt[ltr_df$suburb %in% core.suburbs] <- 'city-core'
#   ltr_df$geo.mrkt[ltr_df$beach == 1] <- 'beach'
#   
#   # Order the factors properly
#   ltr_df$geo.mrkt <- factor(ltr_df$geo.mrkt, 
#                               levels=c('city-core', 'city', 'suburban', 
#                                         'rural', 'beach'))
#   
#   # Count Cleaning
#   countCleaning('location')
#   
# ```
# 
# The location of the short and long term rentals, colored by submarket, are shown below
# 
# ```{r locationmaps.plot, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#   # Set submarket colors
#   
#   sm_col <- abb_col[c(1, 3, 6, 5, 2)]
# 
#   # Make map
# 
#   str.map <- ggplot() +
#     geom_polygon(data=subs, aes(x=long, y=lat, group=group), fill='white', color='grey70') +
#     geom_point(data=str_df, aes(x=longitude, y=latitude, color=geo.mrkt), size=.2,
#                alpha=.2) +
#     scale_color_manual(values=sm_col) +
#     scale_x_continuous(limits=c(min(subs$long), max(subs$long))) +
#     scale_y_continuous(limits=c(min(subs$lat), max(subs$lat))) +
#     xlab('') + ylab('')+
#     theme(legend.position = 'bottom',
#           legend.title = element_blank(),
#           plot.title = element_text(hjust = 0.5),
#           panel.grid.major = element_blank(),
#           panel.grid.minor = element_blank(),
#           panel.background = element_rect(fill = "white"),
#           axis.text.x = element_blank(),
#           axis.text.y = element_blank(),
#           axis.ticks = element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.border = element_rect(colour = "black", fill=NA, size=1)) +
#     guides(colour = guide_legend(override.aes = list(size=3,
#                                                      alpha=1))) + 
#     ggtitle('Short-Term Rental Locations')+
#     theme(plot.title = element_text(hjust = 0.5))
#   
# ```
# 
# ```{r ltr.plot, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#   # Make map
# 
#   ltr.map <- ggplot() +
#     geom_polygon(data=subs, aes(x=long, y=lat, group=group), fill='white', color='grey70') +
#     geom_point(data=ltr_df, aes(x=longitude, y=latitude, color=geo.mrkt), size=.1,
#                alpha=.1) +
#     scale_color_manual(values=sm_col) +
#     scale_x_continuous(limits=c(min(subs$long), max(subs$long))) +
#     scale_y_continuous(limits=c(min(subs$lat), max(subs$lat))) +
#     xlab('') + ylab('')+
#     theme(legend.position = 'bottom',
#           legend.title = element_blank(),
#           plot.title = element_text(hjust = 0.5),
#           panel.grid.major = element_blank(),
#           panel.grid.minor = element_blank(),
#           panel.background = element_rect(fill = "white"),
#           axis.text.x = element_blank(),
#           axis.text.y = element_blank(),
#           axis.ticks = element_blank(),
#           axis.title.x=element_blank(),
#           axis.title.y=element_blank(),
#           panel.border = element_rect(colour = "black", fill=NA, size=1)) +
#     guides(colour = guide_legend(override.aes = list(size=3,
#                                                      alpha=1))) + 
#     ggtitle('Long-Term Rental Locations')+
#     theme(plot.title = element_text(hjust = 0.5))
#   
# ```
# 
# ```{r loc.plot, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE, fig.width=9}
#   
#   png(file=paste0(fig.path, 'str_locmap.png'), width = 680, height = 590, 
#       bg='transparent')
#      str.map
#   dev.off()
#   
#   png(file=paste0(fig.path, 'ltr_locmap.png'), width = 680, height = 590, 
#       bg='transparent')
#      ltr.map
#   dev.off()
# 
#   ggMultiPlots(str.map, ltr.map, cols=2)
#   
#   save(str.map, file=paste0(fig.path, 'strMap.RData'))
#   save(ltr.map, file=paste0(fig.path, 'ltrMap.RData'))
# 
# 
# ```
# 
# The chart below break down the relative frequency of short and long term rental properties across the five submarkets. 
# 
# ```{r smtype.plot, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE, fig.width=9}
# 
#   # Make Airbnb submarket map
#   
#   strtype.map <- ggplot() +
#     geom_bar(data=str_df, aes(x=geo.mrkt, fill=geo.mrkt)) +
#     scale_fill_manual(values=sm_col) +
#     facet_wrap(~type) +
#     ylab('# of Properties\n') + xlab('')+
#     theme(legend.position = 'bottom',
#           legend.title = element_blank(),
#           axis.text.x=element_blank(),
#           axis.ticks.x=element_blank()) +
#     #ggtitle('Short Term Property Type\nBy Submarket')+
#     theme(plot.title = element_text(hjust = 0.5))
#   
#   # Make Long term rental map
# 
#   ltrtype.map <- ggplot() +
#     geom_bar(data=ltr_df, aes(x=geo.mrkt, fill=geo.mrkt)) +
#     scale_fill_manual(values=sm_col) +
#     facet_wrap(~type) +
#     ylab('# of Properties\n') + xlab('')+
#     theme(legend.position = 'bottom',
#           legend.title = element_blank(),
#           axis.text.x=element_blank(),
#           axis.ticks.x=element_blank()) +
#     #ggtitle('Long Term Property Type\nBy Submarket')+
#     theme(plot.title = element_text(hjust = 0.5))
#   
# ```
# 
# ```{r loctype.plot, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE, fig.width=9}
# 
#   png(file=paste0(fig.path, 'submplot.png'), width = 680, height = 590, 
#       bg='transparent')
#     ggMultiPlots(strtype.map, ltrtype.map, cols=2)
#   dev.off()
#     
#   ggMultiPlots(strtype.map, ltrtype.map, cols=2)
#   
#   save(strtype.map, file=paste0(fig.path, 'strsubplot.RData'))
#   save(ltrtype.map, file=paste0(fig.path, 'ltrsubplot.RData'))
# 
#   
# ```
# 
# Finally, we convert the suburb names from factors to character, which will help with the imputation exercises later on. 
# 
# ```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#   # Convert suburbs from factor to character
#   str_df$suburb <- as.character(str_df$suburb)
#   ltr_df$suburb <- as.character(ltr_df$suburb)
#   
# ```
# 
# &nbsp;
# 
# ## Filter Transaction Data
# 
# The previous exercises filtered the property-level data.  We now filter the transaction level datasets so that they only include those property that remain in the filtered property-level datasets
# 
# ```{r filttransdata, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  ## Short term data
#   
#   daily_df <- daily_df[daily_df$property.id %in% str_df$property.id,]
# 
#  ## Long term list data
#   
#   listing.data <- listing.data[listing.data$activity.id %in% ltr_df$activity.id,]
# 
# ```
# 
# ## Summarize Daily Data
# 
# As we have limited the time period of analysis from the expanse of the raw data, we must now re calculate the daily summary information. 
# 
# ```{r redo.daily.summ, message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
# 
#     # Create new cluster
#   abb_cl <- get_default_cluster() 
#   
#   # Register function and variable
#   cluster_copy(abb_cl, abbCalcBookStr)
# 
#   # Summarize daily by property
#   daily_summ <- daily_df %>% 
#     multidplyr::partition(property.id, cluster=abb_cl) %>% 
#     dplyr::do(abbCalcBookStr(.)) %>% 
#     dplyr::collect()
#   
#  # Remove existing 
#  str_df <- str_df %>%
#    dplyr::select(-c(total.days, block.rate, avail.rate, longest.block, nbr.block,
#                     med.block, bookings))
#  
#  # Add summary data to property data
#  str_df <- str_df %>% dplyr::left_join(daily_summ, by='property.id')
# 
# 
# ```
# 
# 
# #### Host Policies
# 
# Here we combine the two Strict (regular and super) cancellation policies into one as there are few 'super' strict and this is used as a factor in future modeling.  We also remove the few observations with missing host policy data
# 
# ```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#  ## ID those with missing cancel policies and remove
# 
#   str_df <- str_df %>% 
#     dplyr::filter(cancel.policy %in% c('Flexible', 'Moderate', 'Strict'))
# 
#  ## ID those with Super Strict and change to Strict  
#   
#   ss60 <- which(str_df$cancel.policy == 'Super Strict 60 Days')
#   str_df$cancel.policy[ss60] <- 'Strict'
# 
#   # Count Cleaning
#   countCleaning('hostpolicy')
#   
#   
# ```
# 
# ## Write out data  
# 
# ```{r message=FALSE, warning=FALSE, comment=FALSE, cache=TRUE, echo=TRUE}
# 
#   save(str_df, ltr_df, daily_df, listing.data, subs, abb_col, 
#        beach.shp, core.suburbs, exch.rate, ltr_col, str_col, sa1s.shp, 
#        suburbs.shp, study.suburbs, clean.count, daily.run.total, list.run.total,
#        ltr.run.total, str.run.total,
#        file=paste0(data_path, 'prepared/prep_workspace_', data_name, '.RData'))
# 
# ```N